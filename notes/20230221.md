# Poznatky 21.02.2023

- tak pmod zase nefunguje ani pro JB, JC, JD, JE, zkusím tedy znovu pouze třeba pro JB
- zase ztráta 2 hodin
- přemýšlel jsem v noci ještě nad interruptem, jak ho zakomponovat v budoucím použití např. s timerem v block designu ve vivado a na základě něho číst data z PMOD portů, kde by bylo třeba SPI enkodér

- co je v kernelu, musí mít vstupy a nemůže počítat s uzavřenou classou a jejími hodnotami
- když nepůjde mít classu v HOST a v PL (abych mohl volat funkce) bude třeba předělat kód a vyndat ty funkce, co mají být v kernelu pryč z classy
- na začátku kernelu udělaat to, že do vytvořené classy do jednotlivých pointerů se vloží získané pointery z přesunu dat, resp. hodnoty těch pointerů, takže adresy na které ukazují
- no ale co to je, udělal jsem JB stejně jako native když to šlo a ono to nejde, není tam vidět GPIO, já fakt nevím..., zkusím ještě bez přegenerování output products
- ne tak to nejde jako pmod-native, nevím proč to předtím šlo, jako nechápu to, to jsem tam musel dát asi něco jiného než native, ale nejsem si jistý co, i když tam native nahraju, tak to nejde

```c++
//MotorModel.h
class MotorModelClass
{
    public:
    float *testFloatPointeruClass = NULL;

};



//main.c

MotorModelClass MotorModel;


float testValue = 5;

std::cout << "testpointer: " << MotorModel.testFloatPointeruClass << "\n"; //outputs null adress
MotorModel.testFloatPointeruClass = &testValue; //adress put in the pointer (likely in kernel to reference it in kernel as easily as posible)

std::cout << "testpointer after value: " << *(MotorModel.testFloatPointeruClass) << "\n"; // outputs value of testValue = 5;
std::cout << "testpointer after value: " << MotorModel.testFloatPointeruClass << "\n"; //outputs adress of testValue
```
