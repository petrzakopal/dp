# Poznatky 21.02.2023

- tak pmod zase nefunguje ani pro JB, JC, JD, JE, zkusÃ­m tedy znovu pouze tÅ™eba pro JB
- zase ztrÃ¡ta 2 hodin
- pÅ™emÃ½Å¡lel jsem v noci jeÅ¡tÄ› nad interruptem, jak ho zakomponovat v budoucÃ­m pouÅ¾itÃ­ napÅ™. s timerem v block designu ve vivado a na zÃ¡kladÄ› nÄ›ho ÄÃ­st data z PMOD portÅ¯, kde by bylo tÅ™eba SPI enkodÃ©r

- co je v kernelu, musÃ­ mÃ­t vstupy a nemÅ¯Å¾e poÄÃ­tat s uzavÅ™enou classou a jejÃ­mi hodnotami
- kdyÅ¾ nepÅ¯jde mÃ­t classu v HOST a v PL (abych mohl volat funkce) bude tÅ™eba pÅ™edÄ›lat kÃ³d a vyndat ty funkce, co majÃ­ bÃ½t v kernelu pryÄ z classy
- na zaÄÃ¡tku kernelu udÄ›laat to, Å¾e do vytvoÅ™enÃ© classy do jednotlivÃ½ch pointerÅ¯ se vloÅ¾Ã­ zÃ­skanÃ© pointery z pÅ™esunu dat, resp. hodnoty tÄ›ch pointerÅ¯, takÅ¾e adresy na kterÃ© ukazujÃ­
- no ale co to je, udÄ›lal jsem JB stejnÄ› jako native kdyÅ¾ to Å¡lo a ono to nejde, nenÃ­ tam vidÄ›t GPIO, jÃ¡ fakt nevÃ­m..., zkusÃ­m jeÅ¡tÄ› bez pÅ™egenerovÃ¡nÃ­ output products
- ne tak to nejde jako pmod-native, nevÃ­m proÄ to pÅ™edtÃ­m Å¡lo, jako nechÃ¡pu to, to jsem tam musel dÃ¡t asi nÄ›co jinÃ©ho neÅ¾ native, ale nejsem si jistÃ½ co, i kdyÅ¾ tam native nahraju, tak to nejde
- celÃ½ den jsem pracoval na pmod bez vÃ½sledku
- takÃ© jsem pracoval na [cmodel](./../code/test-program/cmodel/), kde jsme vyÅ™eÅ¡il nÄ›jakÃ© problÃ©my, udÄ›lal jakoby ASM motor z EPT 2. Ãºlohy, ale Å™eÅ¡enÃ­ je nÄ›jakÃ© divnÃ©, protoÅ¾e nenÃ­ jako v matlabu, bude tÅ™eba to vyÅ™eÅ¡it ğŸ¤“ (sigh...)
- na kontrolu leakÅ¯ (mÄ›l jsem memory leak) je na macOS moÅ¾nÃ© pouÅ¾Ã­vat (Valgrind uÅ¾ nÄ›jak nejde si myslÃ­m, nebo je to sloÅ¾itÄ›jÅ¡Ã­) je fajn `leaks` neboli spustit to na konci procesu/programu `leaks --etExit -- ./main`
- leaks [YouTube â€“ Using Leaks (the valgrind equivalent) on Mac (Shown on M1) to detect memory leaks](https://www.youtube.com/watch?v=bhhDRm926qA)
- pmod mi prostÄ› uÅ¾ nejde, jak jsem to nenahrÃ¡l, tak pÅ™esnÄ› nevÃ­m, jak co to bylo...

- **PMOD Z PL SE POVEDLO** - je to tÅ™eba dÄ›lat tak, Å¾e se vloÅ¾Ã­ `axi gpio` blok a ten se namapuje pomocÃ­ constrains, je tÅ™eba ale zmÄ›nit keho vÃ½stup na `external` a oznaÄÃ­t tÅ™eba `jb`, potÃ© aÅ¾ se vloÅ¾ili i buttons, led a switch tak udÄ›lat automatizaci, generate output products, generate hdl wrapper, podÃ­vat se na oznaÄenÃ­ inout pro jednotlivÃ© gpio co jsem tam dal `jb` atd., vÄ›tÅ¡inou je to `tri io`, potÃ© namapovat v constrains, potÃ© generate output products (myslÃ­m), pak syntÃ©za, implementace, bitstream, petalinux klasicky, vitis + nezapomenout knihovnu na debugging (ne v production) a je to
- video kde o tom mluvÃ­m [YouTube](https://youtu.be/7i3YK1_SCRs)

```c++
//MotorModel.h
class MotorModelClass
{
    public:
    float *testFloatPointeruClass = NULL;

};



//main.c

MotorModelClass MotorModel;


float testValue = 5;

std::cout << "testpointer: " << MotorModel.testFloatPointeruClass << "\n"; //outputs null adress
MotorModel.testFloatPointeruClass = &testValue; //adress put in the pointer (likely in kernel to reference it in kernel as easily as posible)

std::cout << "testpointer after value: " << *(MotorModel.testFloatPointeruClass) << "\n"; // outputs value of testValue = 5;
std::cout << "testpointer after value: " << MotorModel.testFloatPointeruClass << "\n"; //outputs adress of testValue
```
