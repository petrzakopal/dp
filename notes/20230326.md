# Poznatky 26.03.2023

## Uložení refactoringu s array v regulátorech a a hostu ještě s xrt...

```c++
/*******************************************************************************
Author: FEE CVUT
Purpose: Kernel
*******************************************************************************/
// Includes
#include <stdint.h>
#include <hls_stream.h>
#include <hls_math.h>
#include "function/regulator.cpp"
#include "function/svmCore.cpp"

// #include "function/transformation.cpp"
#define PI 3.141592
extern "C" {

    /*
    * @name sliceInternalVariables4Parts
    * @brief Function to calculate slice variables at 4 parts
    */

    void sliceInternalVariables4Parts(float variableIn, float *variableOut)
    {
        for(int i = 0;i<4;i++)
        {
            variableOut[i] = variableIn;
        }
    }

    /*
    * @name sliceInternalVariables8Parts
    * @brief Function to calculate slice variables at 4 parts
    */

    void sliceInternalVariables8Parts(float variableIn, float *variableOut)
    {
        for(int i = 0;i<8;i++)
        {
            variableOut[i] = variableIn;
        }
    }

     void sliceInternalVariables3Parts(float variableIn, float *variableOut)
    {
        for(int i = 0;i<3;i++)
        {
            variableOut[i] = variableIn;
        }
    }


    /*
    * @name psi2alphaFce
    * @brief Function to calculate new psi2alpha in RK4 CurVel Model
    */

    float psi2alphaFce(float R2MLmDL2, float R2DL2, float i1alpha, float i1beta, float psi2alpha, float psi2beta, float motorElectricalAngularVelocity )
    {
        return((R2MLmDL2 * i1alpha) - (motorElectricalAngularVelocity * psi2beta) - (R2DL2 * psi2alpha));
    }

    /*
    * @name psi2betaFce
    * @brief Function to calculate new psi2beta in RK4 CurVel Model
    */

    float psi2betaFce(float R2MLmDL2, float R2DL2, float i1alpha, float i1beta, float psi2alpha, float psi2beta, float motorElectricalAngularVelocity)
    {
        return((R2MLmDL2 * i1beta) + (motorElectricalAngularVelocity * psi2alpha) - (R2DL2 * psi2beta));
    }

    void computeCurVel(float *psi2alpha, float *psi2beta, float inputI1, float inputI2, float inputI3, float numberOfPolePairs, float *R2MLmDL2Temp, float *R2DL2Temp, float inputMotorMechanicalAngularVelocity, float globalSimulationTime, float globalCalculationStep, float halfCalculationStep, float *i1alpha, float *i1beta)
    {

        // coefficients for RK4
        float k1psi2alpha, k2psi2alpha, k3psi2alpha, k4psi2alpha;
        float k1psi2beta, k2psi2beta, k3psi2beta, k4psi2beta;
        // helper variable to reduce calculation fo the same value

        float psi2alphaTemp[8];
        float psi2betaTemp[8];
        float i1alphaTemp[8];
        float i1betaTemp[8];
        float k1psi2alphaTemp[4];
        float k1psi2betaTemp[4];
        float k2psi2alphaTemp[4];
        float k2psi2betaTemp[4];
        float k3psi2alphaTemp[4];
        float k3psi2betaTemp[4];
        float motorElectricalAngularVelocityTemp[8];
        float motorElectricalAngularVelocity;
        float calculationStep = globalCalculationStep;
        float k4psi2alphaTemp1;
        float k4psi2betaTemp1;



        #pragma HLS performance target_ti=1
        #pragma HLS loop_tripcount max=1

        sliceInternalVariables8Parts(*psi2alpha, psi2alphaTemp);
        sliceInternalVariables8Parts(*psi2beta, psi2betaTemp);

        *i1alpha = (0.667 * (inputI1 - (0.5 * inputI2) - (0.5 * inputI3)));
        *i1beta = (0.6667 * (0.866 * inputI2 - 0.866 *  inputI3));

        sliceInternalVariables8Parts(*i1alpha, i1alphaTemp);
        sliceInternalVariables8Parts(*i1beta, i1betaTemp);

        motorElectricalAngularVelocity = inputMotorMechanicalAngularVelocity * numberOfPolePairs;

        sliceInternalVariables8Parts(motorElectricalAngularVelocity, motorElectricalAngularVelocityTemp);


        /*------------------------------------------------------------------------------------------------------------------------------------*/
        k1psi2alpha = psi2alphaFce(R2MLmDL2Temp[0], R2DL2Temp[0] , i1alphaTemp[0], i1betaTemp[0], psi2alphaTemp[0], psi2betaTemp[0], motorElectricalAngularVelocityTemp[0]);

        k1psi2beta = psi2betaFce(R2MLmDL2Temp[1], R2DL2Temp[1], i1alphaTemp[1], i1betaTemp[1], psi2alphaTemp[1], psi2betaTemp[1], motorElectricalAngularVelocityTemp[1]);
    /*------------------------------------------------------------------------------------------------------------------------------------*/


        sliceInternalVariables4Parts(k1psi2alpha, k1psi2alphaTemp);

        sliceInternalVariables4Parts(k1psi2beta, k1psi2betaTemp);

    /*------------------------------------------------------------------------------------------------------------------------------------*/
        k2psi2alpha = psi2alphaFce(R2MLmDL2Temp[2], R2DL2Temp[2] , i1alphaTemp[2], i1betaTemp[2], (psi2alphaTemp[2] + (halfCalculationStep * k1psi2alphaTemp[0])), (psi2betaTemp[2] + (halfCalculationStep * k1psi2betaTemp[0])), motorElectricalAngularVelocityTemp[2]);

        k2psi2beta = psi2betaFce(R2MLmDL2Temp[3], R2DL2Temp[3], i1alphaTemp[3], i1betaTemp[3], (psi2alphaTemp[3] + (halfCalculationStep * k1psi2alphaTemp[1])), (psi2betaTemp[3] + (halfCalculationStep * k1psi2betaTemp[1])), motorElectricalAngularVelocityTemp[3]);
    /*------------------------------------------------------------------------------------------------------------------------------------*/



        sliceInternalVariables4Parts(k2psi2alpha, k2psi2alphaTemp);

        sliceInternalVariables4Parts(k2psi2beta, k2psi2betaTemp);


    /*------------------------------------------------------------------------------------------------------------------------------------*/
        k3psi2alpha = psi2alphaFce(R2MLmDL2Temp[4], R2DL2Temp[4] , i1alphaTemp[4], i1betaTemp[4], (psi2alphaTemp[4] + (halfCalculationStep * k2psi2alphaTemp[0])), (psi2betaTemp[4] + (halfCalculationStep * k2psi2betaTemp[0])), motorElectricalAngularVelocityTemp[4]);

        k3psi2beta = psi2betaFce(R2MLmDL2Temp[5], R2DL2Temp[5] , i1alphaTemp[5], i1betaTemp[5], (psi2alphaTemp[5] + (halfCalculationStep * k2psi2alphaTemp[1])), (psi2betaTemp[5] + (halfCalculationStep * k2psi2betaTemp[1])), motorElectricalAngularVelocityTemp[5]);
    /*------------------------------------------------------------------------------------------------------------------------------------*/

        sliceInternalVariables4Parts(k3psi2alpha, k3psi2alphaTemp);


        sliceInternalVariables4Parts(k3psi2beta, k3psi2betaTemp);

    /*------------------------------------------------------------------------------------------------------------------------------------*/
        k4psi2alpha = psi2alphaFce(R2MLmDL2Temp[6], R2DL2Temp[6] , i1alphaTemp[6], i1betaTemp[6], (psi2alphaTemp[6] + (calculationStep * k3psi2alphaTemp[0])), (psi2betaTemp[6] + (calculationStep * k3psi2betaTemp[0])), motorElectricalAngularVelocityTemp[6]);

        k4psi2beta = psi2betaFce(R2MLmDL2Temp[7], R2DL2Temp[7] , i1alphaTemp[7], i1betaTemp[7], (psi2alphaTemp[7] + (calculationStep * k3psi2alphaTemp[1])), (psi2betaTemp[7] + (calculationStep * k3psi2betaTemp[1])), motorElectricalAngularVelocityTemp[7]);
    /*------------------------------------------------------------------------------------------------------------------------------------*/

        k4psi2alphaTemp1 = k4psi2alpha;
        k4psi2betaTemp1 = k4psi2beta;



        *psi2alpha = *psi2alpha + ((calculationStep / 6) * (k1psi2alphaTemp[3] + 2 * k2psi2alphaTemp[3] + 2 * k3psi2alphaTemp[3] + k4psi2alphaTemp1));


        *psi2beta = *psi2beta + ((calculationStep / 6) * (k1psi2betaTemp[3] + 2 * k2psi2betaTemp[3] + 2 * k3psi2betaTemp[3] + k4psi2betaTemp1));

    }


    void outputCurVelProductsCalc(float *transformAngle, float *psi2amplitude, float psi2alpha, float psi2beta)
    {
        float psi2alphaTemp = psi2alpha;
        float psi2betaTemp = psi2beta;

        *psi2amplitude = sqrtf((psi2alphaTemp * psi2alphaTemp) + (psi2betaTemp * psi2betaTemp));
        *transformAngle = atan2f(psi2betaTemp, psi2alphaTemp);
    }



    float generateActualValueTriangleWave(TriangleWaveSettingsType *triangleWaveSettings)
    {
        float triangleActualValue; // maybe put in triangleWaveSettings, and make this function void, do not know, this should be used only as a local variable

        // numerical method with abs value and modulo
        triangleActualValue = (((4 * triangleWaveSettings->waveAmplitude)/triangleWaveSettings->wavePeriod) * abs(fmod((fmod((triangleWaveSettings->calculationTime-(triangleWaveSettings->wavePeriod/4)), triangleWaveSettings->wavePeriod) +  triangleWaveSettings->wavePeriod),  triangleWaveSettings->wavePeriod) - ( triangleWaveSettings->wavePeriod/2)) - triangleWaveSettings->waveAmplitude);

        // trigoniometric method
        // triangleActualValue = ((2 * triangleWaveSettings->waveAmplitude)/3.145192)*asin(sin(((2 * 3.145192)/triangleWaveSettings->wavePeriod) * triangleWaveSettings->calculationTime));

        // updating inner wave calculation time based on set initial value of calculationTime...
        triangleWaveSettings->calculationTime = triangleWaveSettings->calculationTime + triangleWaveSettings->calculationStep;

        return(triangleActualValue);
    }

void regCalculateHls(float *regulatorFloatData)
{
   regulatorFloatData[5] = regulatorFloatData[1] - regulatorFloatData[2];

   regulatorFloatData[0] = (regulatorFloatData[5] * regulatorFloatData[7]) + regulatorFloatData[6];

    bool regulatorBoolData[3];
    float localRegulatorFloatData0[3];
    float localRegulatorFloatData9[2];
    float localRegulatorFloatData10[2];

    for(int i = 0;i<2;i++)
    {
        localRegulatorFloatData9[i] = regulatorFloatData[9];
    }

    for(int i = 0;i<2;i++)
    {
        localRegulatorFloatData10[i] = regulatorFloatData[10];
    }

    for(int i = 0;i<2;i++)
    {
        localRegulatorFloatData0[i] = regulatorFloatData[0];
    }

   if(localRegulatorFloatData0[0] > localRegulatorFloatData9[0])
   {
        localRegulatorFloatData0[1] = localRegulatorFloatData9[1];
   }
   else if(localRegulatorFloatData0[0] < localRegulatorFloatData10[0])
   {
         localRegulatorFloatData0[1] = localRegulatorFloatData10[1];
   }
    regulatorFloatData[3] = localRegulatorFloatData0[1];


    if(regulatorFloatData[0] == regulatorFloatData[3])
    {
        regulatorBoolData[1] = false;
    }
    else
    {
        regulatorBoolData[1] = true;
    }


    if(((regulatorFloatData[5] > 0) and (regulatorFloatData[0] > 0)) or ((regulatorFloatData[5] < 0) and (regulatorFloatData[0] < 0)))
    {
        regulatorBoolData[2] = true;
    }
    else
    {
        regulatorBoolData[2] = false;
    }

    if((regulatorBoolData[1] ==true) and (regulatorBoolData[2] ==true))
    {
        regulatorBoolData[0] =true;
    }
    else
    {
        regulatorBoolData[0] =false;
    }


    if(regulatorBoolData[0] ==true)
    {
        regulatorFloatData[6] = regulatorFloatData[6];
    }
    else
    {
        regulatorFloatData[6] = regulatorFloatData[6] + (regulatorFloatData[5] * regulatorFloatData[8]);
    }

}

    float minMaxCommonModeVoltage(CoreInternalVariablesType *coreInternalVariables)
    {
        return(((fmax(fmax(coreInternalVariables->u1a, coreInternalVariables->u1b), coreInternalVariables->u1c ) ) + (fmin(fmin(coreInternalVariables->u1a, coreInternalVariables->u1b), coreInternalVariables->u1c ) ))/2);
    }

    bool comparationLevelTriangleWaveComparation(float compareLevel, float triangleWaveValue)
    {
        if(compareLevel>=triangleWaveValue)
        {
            return(true);
        }
        else
        {
            return(false);
        }
    }

    float createCompareLevel(float levelConstant, float commonModeVoltage, float phaseWantedVoltage)
    {
        return((phaseWantedVoltage - commonModeVoltage)/levelConstant);
    }

    void krnl_calculateCurVelModel(float *masterInput, float *masterOutput )
    {
        #pragma HLS INTERFACE mode = m_axi port = masterInput bundle = gmem0
        #pragma HLS INTERFACE mode = m_axi port = masterOutput bundle = gmem1
        #pragma HLS performance target_ti=1

        CoreInternalVariablesType coreInternalVariables;
        TriangleWaveSettingsType triangleWaveSettings;
        InvertorSwitchType invertorSwitch;

         /*
        * @brief Initial values settings
        *
        * */
        float R2MLmDL2Temp[8];
        float R2DL2Temp[8];
        float transformationAngle;
        float psi2amplitude;
        float trianglePoint;
        float commonModeVoltage;
        float psi2alpha;
        float psi2beta;
        float i1alpha;
        float i1beta;

        float globalSimulationTime = masterInput[0];
        float globalCalculationStep =masterInput[1];
        float minMaxCommonModeVoltageConstant = masterInput[2];
        float minMaxCommonModeVoltageConstantTemp[3];
        float halfCalculationStep = globalCalculationStep/2;
        float inputI1 = masterInput[4];
        float inputI2 = masterInput[5];
        float inputI3 = masterInput[6];
        float inputMotorMechanicalAngularVelocity = masterInput[7];
        float R2MLmDL2 = masterInput[8];
        float R2DL2 = masterInput[9];
        float numberOfPolePairs = masterInput[10];
        triangleWaveSettings.waveAmplitude = masterInput[11];
        triangleWaveSettings.calculationStep = masterInput[12];
        triangleWaveSettings.wavePeriod = masterInput[13];
        triangleWaveSettings.calculationTime = masterInput[14];
        float Udcmax = masterInput[15];

        float fluxRegulatorFloatData[11];
        bool fluxRegulatorBoolData[3];

        fluxRegulatorFloatData[8] = masterInput[16];
        fluxRegulatorFloatData[7] = masterInput[17];
        fluxRegulatorFloatData[9] = masterInput[18];
        fluxRegulatorFloatData[10] = masterInput[19];
        fluxRegulatorFloatData[6] = masterInput[20];


        float velocityRegulatorFloatData[11];


        velocityRegulatorFloatData[8] = masterInput[21];
        velocityRegulatorFloatData[7] = masterInput[22];
        velocityRegulatorFloatData[9] = masterInput[23];
        velocityRegulatorFloatData[10] = masterInput[24];
        velocityRegulatorFloatData[6] = masterInput[25];



        float iDregulatorFloatData[11];

        iDregulatorFloatData[3] = masterInput[28];
        iDregulatorFloatData[6] = masterInput[29];
        iDregulatorFloatData[7] = masterInput[27];
        iDregulatorFloatData[8] = masterInput[26];


        float iQregulatorFloatData[11];


        iQregulatorFloatData[6] = masterInput[30];
        iQregulatorFloatData[7] = masterInput[31];
        iQregulatorFloatData[8] = masterInput[32];

        fluxRegulatorFloatData[1] = masterInput[33];
        velocityRegulatorBoolData[1] = masterInput[34];

        iDregulatorFloatData[1] = masterInput[35];
        iQregulatorFloatData[1] = masterInput[36];

        psi2alpha = masterInput[37];
        psi2beta = masterInput[38];

        sliceInternalVariables8Parts(R2MLmDL2, R2MLmDL2Temp);
        sliceInternalVariables8Parts(R2DL2, R2DL2Temp);

        float *psi2alpha_ptr = &psi2alpha;
        float *psi2beta_ptr = &psi2beta;
        float *i1alpha_ptr = &i1alpha;
        float *i1beta_ptr = &i1beta;
        float *transformationAngle_ptr = &transformationAngle;
        float *psi2amplitude_ptr = &psi2amplitude;
        float transformationAngleTemp[8];
        float commonModeVoltageTemp[3];
        float trianglePointTemp[3];

        computeCurVel(psi2alpha_ptr, psi2beta_ptr, inputI1, inputI2, inputI3, numberOfPolePairs, R2MLmDL2Temp, R2DL2Temp, inputMotorMechanicalAngularVelocity, globalSimulationTime, globalCalculationStep, halfCalculationStep, i1alpha_ptr, i1beta_ptr);


        outputCurVelProductsCalc(transformationAngle_ptr, psi2amplitude_ptr, psi2alpha, psi2beta);

        sliceInternalVariables8Parts(transformationAngle, transformationAngleTemp);

        // regulator new values + constrains
        iDregulatorFloatData[2] = ((i1alpha * cosf(transformationAngleTemp[0])) + (i1beta * sinf(transformationAngleTemp[1])));
        iQregulatorFloatData[2] = ((-i1alpha * sinf(transformationAngleTemp[2])) + (i1beta * cosf(transformationAngleTemp[3])));


        fluxRegulatorFloatData[2] = psi2amplitude;
        velocityRegulatorBoolData[2] = inputMotorMechanicalAngularVelocity;
        iQregulatorFloatData[9] = sqrtf((Udcmax * Udcmax) - (iDregulatorFloatData[3] * iDregulatorFloatData[3]));
        iQregulatorFloatData[10] = - iQregulatorFloatData[9];




        // calculating first set of regulators
        regCalculateHls(fluxRegulatorFloatData);
        regCalculateHls(velocityRegulatorBoolData);

        // new values
        iDregulatorFloatData[1] = fluxRegulatorFloatData[3];
        iQregulatorFloatData[1] = velocityRegulatorBoolData[3];

         // calculating second set of regulators
        regCalculateHls(iDregulatorFloatData);
        regCalculateHls(iQregulatorFloatData);

        coreInternalVariables.u1d = iDregulatorFloatData[3];
        coreInternalVariables.u1q = iQregulatorFloatData[3];

        coreInternalVariables.u1alpha = ((coreInternalVariables.u1d * cosf(transformationAngleTemp[4])) - (coreInternalVariables.u1q * sinf(transformationAngleTemp[5])));
        coreInternalVariables.u1beta = ((coreInternalVariables.u1d * sinf(transformationAngleTemp[6])) + (coreInternalVariables.u1q * cosf(transformationAngleTemp[7])));

        coreInternalVariables.u1a = coreInternalVariables.u1alpha;
        coreInternalVariables.u1b = ((-0.5 * coreInternalVariables.u1alpha) + 0.866 * coreInternalVariables.u1beta);
        coreInternalVariables.u1c = ((-0.5 * coreInternalVariables.u1alpha) - 0.866 * coreInternalVariables.u1beta);

        trianglePoint = generateActualValueTriangleWave(&triangleWaveSettings);
        commonModeVoltage = minMaxCommonModeVoltage(&coreInternalVariables);

        sliceInternalVariables3Parts(commonModeVoltage, commonModeVoltageTemp);
        sliceInternalVariables3Parts(trianglePoint, trianglePointTemp);
        sliceInternalVariables3Parts(minMaxCommonModeVoltageConstant, minMaxCommonModeVoltageConstantTemp);

        invertorSwitch.sw1 = comparationLevelTriangleWaveComparation(createCompareLevel(minMaxCommonModeVoltageConstantTemp[0], commonModeVoltageTemp[0],coreInternalVariables.u1a), trianglePointTemp[0]);

        invertorSwitch.sw3 = comparationLevelTriangleWaveComparation(createCompareLevel(minMaxCommonModeVoltageConstantTemp[1], commonModeVoltageTemp[1],coreInternalVariables.u1b), trianglePointTemp[1]);

        invertorSwitch.sw5 = comparationLevelTriangleWaveComparation(createCompareLevel(minMaxCommonModeVoltageConstantTemp[2], commonModeVoltageTemp[2],coreInternalVariables.u1c), trianglePointTemp[2]);

        invertorSwitch.sw4 = !invertorSwitch.sw1;
        invertorSwitch.sw6 = !invertorSwitch.sw3;
        invertorSwitch.sw2 = !invertorSwitch.sw5;


        masterOutput[0] = invertorSwitch.sw1;
        masterOutput[1] = invertorSwitch.sw2;
        masterOutput[2] = invertorSwitch.sw3;
        masterOutput[3] = invertorSwitch.sw4;
        masterOutput[4] = invertorSwitch.sw5;
        masterOutput[5] = invertorSwitch.sw6;

        masterOutput[6] = triangleWaveSettings.calculationTime;
        masterOutput[7] = fluxRegulatorFloatData[6];
        masterOutput[8] =velocityRegulatorFloatData[6];
        masterOutput[9] = iDregulatorFloatData[3];
        masterOutput[10] = iDregulatorFloatData[6];
        masterOutput[11] = iQregulatorFloatData[6];
        masterOutput[12] = psi2alpha;
        masterOutput[13] = psi2beta;
        masterOutput[14] = psi2amplitude;
        masterOutput[15] = iDregulatorFloatData[2];
        masterOutput[16] = iDregulatorFloatData[1];
        masterOutput[17] = transformationAngle;
    }


}


```

```c++
/*******************************************************************************
Author: FEE CTU
Purpose: Host program
Comment: Refactoring for HLS
*******************************************************************************/
/*----------------------------------------------------------------------------*/
/*-------------------------------- INCLUDES ---------------------------------*/
#include "allocator.h"
#include <iostream>
#include <stdlib.h>
#include <string>
#include <fstream>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include "header/MotorModel.h"
#include "header/CurVelModel.h"
#include "header/regulator.h"
// #include "header/svmCore.h" // already in invertor
#include "header/transformation.h"
#include "header/invertor.h"

#include <stdio.h>
#include <chrono>
#include <thread>
#include <mutex>
#include <future>

#include "experimental/xrt_profile.h" // for profiling host program
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*-------------------- INFO FUNCTION FOR PRINTING ERRORS --------------------*/
#define OCL_CHECK(error, call)                                                                   \
    call;                                                                                        \
    if (error != CL_SUCCESS) {                                                                   \
        printf("%s:%d Error calling " #call ", error code is: %d\n", __FILE__, __LINE__, error); \
        exit(EXIT_FAILURE);                                                                      \
}
/*----------------------------------------------------------------------------*/



/*----------------------------------------------------------------------------*/
/*--------------------------- CONSTANT DEFINITION ---------------------------*/
#define PI 3.141592
/*----------------------------------------------------------------------------*/








// Define the function to be called when ctrl-c (SIGINT) is sent to process
void signal_callback_handler(int signum) {
   std::cout << "\nCaught signal " << signum << "\n";
   // Terminate program
   exit(signum);
}
/*------------------------------------------------------------------------------------*/
/*-------------------------------- MAIN HOST PROGRAM ---------------------------------*/
int main(int argc, char* argv[]) {

    // Register signal and signal handler
   signal(SIGINT, signal_callback_handler);




    /*-|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-*/
    /*-------------------------------- SETTING THE ENVIRONMENT ---------------------------------*/
    // TARGET_DEVICE macro needs to be passed from gcc command line
    if (argc != 2)
    {
        std::cout << "Usage: " << argv[0] << " <xclbin>" << std::endl;
        return EXIT_FAILURE;
    }

    std::string xclbinFilename = argv[1];

    /*-------------------------------------------------------------------------------------*/
    /*-------------------------------- OPENCL DEFINITIONS ---------------------------------*/
    std::vector<cl::Device> devices;
    cl_int err;
    cl::Context context;
    cl::CommandQueue q;
    cl::Program program;
    std::vector<cl::Platform> platforms;
    bool found_device = false;
    /*-----------------------------------------------------------------------------------------*/

    /*-------------------------------- OPENCL KERNEL CREATION ---------------------------------*/
    cl::Kernel krnl_calculateCurVelModel;
    // cl::Kernel krnl_GenerateVoltageAlphaBeta;
    /*----------------------------------------------------------------------------------------*/


    /*-------------------------------------------------------------------------------------*/
    /*------------------------- PLATFORM SEARCHING AND SELECTING --------------------------*/

    // Searching through devices on a platform and connecting from CPU to device (PL)
    cl::Platform::get(&platforms);

    // Loop through all the platforms based on a vector of platforms size till the device is found (found_device==true)
    for (size_t i = 0; (i < platforms.size()) & (found_device == false); i++)
    {
        cl::Platform platform = platforms[i];
        std::string platformName = platform.getInfo<CL_PLATFORM_NAME>();

        // If the found device is Xilinx device
        if (platformName == "Xilinx")
        {
            devices.clear();
            // Gets list of devices for selected platform and pastes them on the adress of devices Device
            platform.getDevices(CL_DEVICE_TYPE_ACCELERATOR, &devices);
            if (devices.size())
            {
                found_device = true;
                break;
            }
        }
    }

    if (found_device == false) {
        std::cout << "Error: Unable to find Target Device " << std::endl;
        return EXIT_FAILURE;
    }
    /*-------------------------------------------------------------------------------------*/


    /*-------------------------------------------------------------------------------------*/
    /*--------------------- LOADING AND READING XCLBIN FILE TO FPGA ----------------------*/
    // Check for availability of PL program
    std::cout << "INFO: Reading " << xclbinFilename << std::endl;
    FILE* fp;
    if ((fp = fopen(xclbinFilename.c_str(), "r")) == nullptr)
    {
        printf("ERROR: %s xclbin not available please build\n", xclbinFilename.c_str());
        exit(EXIT_FAILURE);
    }

    // Load xclbin
    std::cout << "Loading: '" << xclbinFilename << "'\n";
    std::ifstream bin_file(xclbinFilename, std::ifstream::binary);

    // Sets the position of the next character to be extracted from the input stream.
    // istream& seekg (streamoff off, ios_base::seekdir way); off = offset from way - where you are offseting from
    // Basically moving pointer in the stream
    bin_file.seekg(0, bin_file.end);
    unsigned nb = bin_file.tellg();  // Returns the position of the current character in the input stream.
    bin_file.seekg(0, bin_file.beg); // Setting position of the next character to be extracted from the input stream
    char* buf = new char[nb]; // Creating buffer/array with the length of the stream => bin_file

    // buf - pointer of the array where the extracted characters are stored
    // nb – number of characters to extract.
    bin_file.read(buf, nb);

    /*-------------------------------------------------------------------------------------*/

    /*-------------------------------------------------------------------------------------*/
    /*------------------------------- PROGRAMMING THE FPGA -------------------------------*/
    // Creating Program from Binary File
    cl::Program::Binaries bins;
    // {} initialization of vector - array
    // push_back - Adds a new element at the end of the vector, after its current last element.
    bins.push_back({buf, nb});
    bool valid_device = false;


    for (unsigned int i = 0; i < devices.size(); i++)
    {
        auto device = devices[i];
        // Creating Context and Command Queue for selected Device

        OCL_CHECK(err, context = cl::Context(device, nullptr, nullptr, nullptr, &err));

        OCL_CHECK(err, q = cl::CommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, &err));

        std::cout << "Trying to program device[" << i << "]: " << device.getInfo<CL_DEVICE_NAME>() << std::endl;

        // cl:Program - Construct a program object from a list of devices and a per-device list of binaries.
        cl::Program program(context, {device}, bins, nullptr, &err);

        if (err != CL_SUCCESS)
        {
            std::cout << "Failed to program device[" << i << "] with xclbin file!\n";
        }
        else
        {
            std::cout << "Device[" << i << "]: program successful!\n";


            /*-------------------------------- SELECTING KERNEL FROM KERNEL FILE ---------------------------------*/

            // This call will get the kernel object from program. A kernel is an
            // OpenCL function that is executed on the FPGA.
            OCL_CHECK(err, krnl_calculateCurVelModel = cl::Kernel(program, "krnl_calculateCurVelModel", &err)); // assign to krnl_compute the new PL kernel, which is found in kernel_main and called kernel_main

            valid_device = true;



            break; // break because found a valid device

            /*------------------------------------------------------------------------------------------------------*/
        }
    }
    if (!valid_device) {
        std::cout << "Failed to program any device found, exit!\n";
        exit(EXIT_FAILURE);
    }

    /*-------------------------------- END OF SETTING THE ENVIRONMENT ---------------------------------*/
    /*-||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-*/

    /****************************************************************************************************************/


    /*
    * @name The App
    * @brief Main CPU and FPGA application.
    */

    int modeSelection = 0;
    printf("Select mode:\n0 - preloaded data (disabled)\n1 - keyboard input data (disabled)\n2 - CPU/FPGA model\n");
    scanf("%i", &modeSelection);
    printf("You have selected: %i\n\r", modeSelection);


    int masterInputLength = 39;
    int masterOutputLength = 18;

    float *masterInput;
    float *masterOutput;

    posix_memalign((void **)&masterInput , 4096 , (masterInputLength)*sizeof(float) );
    posix_memalign((void **)&masterOutput , 4096 , (masterOutputLength)*sizeof(float) );

    OCL_CHECK(err, cl::Buffer buffer_masterInput(context, CL_MEM_USE_HOST_PTR, (masterInputLength)*sizeof(float),masterInput,&err));
    OCL_CHECK(err, cl::Buffer buffer_masterOutput(context, CL_MEM_USE_HOST_PTR, (masterOutputLength)*sizeof(float),masterOutput,&err));


    int narg = 0;
    OCL_CHECK(err, err = krnl_calculateCurVelModel.setArg(narg++, buffer_masterInput));
    OCL_CHECK(err, err = krnl_calculateCurVelModel.setArg(narg++, buffer_masterOutput));







    /*-------------------------------------------------------------*/
    /*-------------------- CLASS DEFINITIONS ---------------------*/
    MotorModelClass MotorModel;
    svmCoreClass svmCore;
    CurVelModelClass CurVelModel;
    RegulatorClass Regulator;
    TransformationClass Transformation;
    InvertorClass Invertor;
    /*-------------------------------------------------------------*/

    /*-----------------------------------------------------------*/
    /*-------------------- GLOBAL SETTINGS ---------------------*/
    // global settings which will be translated in additional parameters
    float globalCalculationStep = 0.000001;
    float globalInitialCalculationTime = 0;
    float globalFinalCalculationTime = 1;
    // float commonModeVoltage;
    // float compareLevel;
    // float trianglePoint;
    float minMaxCommonModeVoltageConstant = 287;
    float uS = 400;
    float uDC = ((3 * sqrt(2))/PI) * uS;
    float globalSimulationTime = globalInitialCalculationTime;
    /*-------------------------------------------------------------*/


    /****************************************************************/
    /*-------------------- MEMORY ALLOCATION ---------------------*/


    /*-------------------- ASYNCHRONOUS MOTOR MODEL ---------------------*/
    MotorModel.odeCalculationSettingsAllocateMemory();


    // needed for further memory allocation
    MotorModel.setOdeCalculationSettings(globalInitialCalculationTime, globalFinalCalculationTime, globalCalculationStep);

    MotorModel.motorParametersAllocateMemory();
    MotorModel.stateSpaceCoeffAllocateMemory();
    MotorModel.modelVariablesForOnlineCalculationAllocateMemory();
    // MotorModel.voltageGeneratorDataAllocateMemory();
    /*-------------------- END OF ASYNCHRONOUS MOTOR MODEL ---------------------*/

    /*-------------------- CURRENT VELOCITY MOTOR MODEL ---------------------*/
    CurVelModel.motorParametersAllocateMemory();
    CurVelModel.motorCoeffAllocateMemory();
    CurVelModel.modelCVVariablesAllocateMemory();
    CurVelModel.odeCVCalculationSettingsAllocateMemory();
    /*---------------- END OF CURRENT VELOCITY MOTOR MODEL -----------------*/


    /*-------------------- SPACE VECTOR MODULATION CORE ---------------------*/
    // svmCore.phaseWantedVoltageAllocateMemory(); // depracated
    svmCore.invertorSwitchAllocateMemory();
    svmCore.triangleWaveSettingsAllocateMemory();
    svmCore.coreInternalVariablesAllocateMemory();
    /*----------------------------------------------------------------------*/

    /*-------------------- REGULATORS ---------------------*/
    Regulator.regulatorAllocateMemory();
    /*---------------------------------------------------*/


    /*-------------------- INVERTOR ---------------------*/
    Invertor.reconstructedInvertorOutputVoltageAllocateMemory();

    /****************************************************************/


    /*----------------------------- SET ASYNCHRONOUS MOTOR PARAMETERS FOR MODEL ------------------------------*/
    // MotorModel.setMotorParameters(); // hardcoded values
    MotorModel.motorParameters->R1 = 0.370f; // Ohm, stator rezistance
    MotorModel.motorParameters->R2 = 0.225f; // Ohm, rotor rezistance
    MotorModel.motorParameters->L1s = 0.00227f; // H, stator leakage inductance
    MotorModel.motorParameters->L2s = 0.00227f; // H, rotor leakage inductance
    MotorModel.motorParameters->Lm = 0.0825f; // H, main flux inductance
    MotorModel.motorParameters->L1 = 0.08477f; // H, inductance
    MotorModel.motorParameters->L2 = 0.08477f; // H, inductance
    MotorModel.motorParameters->sigma = 0.05283f; // = 0.0528396032, sigma = 1 - Lm^(2)/L1L2
    MotorModel.motorParameters->nOfPolePairs = 2; // number of pole pairs
    MotorModel.motorParameters->momentOfIntertia = 0.4; // J, moment of inertia
    MotorModel.setStateSpaceCoeff();
    MotorModel.odeCalculationSettings->numberOfIterations = MotorModel.numberOfIterations();

    // initial values of ASM model
    MotorModel.modelVariables->i1alpha = 0;
    MotorModel.modelVariables->i1beta = 0;
    MotorModel.modelVariables->psi2alpha = 0;
    MotorModel.modelVariables->psi2beta = 0;
    MotorModel.modelVariables->loadTorque = 0;
    MotorModel.modelVariables->motorMechanicalAngularVelocity = 0;
    MotorModel.modelVariables->motorTorque = 0;
    MotorModel.modelVariables->u1alpha = 0;
    MotorModel.modelVariables->u1beta = 0;

    /*------------------------------------------------------------------------------------------*/
    /*-------------------- CURRENT VELOCITY MODEL SETTINGS/ INITIAL VALUES ---------------------*/
    CurVelModel.modelCVVariables->psi2alpha = 0;
    CurVelModel.modelCVVariables->psi2beta = 0;
    CurVelModel.modelCVVariables->transformAngle = 0;
    CurVelModel.odeCVCalculationSettings->calculationStep = globalCalculationStep; // just a helper variable defined on top of this file to hava the same number of samples for ASM motor model and Current-Velocity model
    CurVelModel.motorParameters->R2 = 0.225f; // Ohm, rotor rezistance
    CurVelModel.motorParameters->Lm = 0.0825f; // H, main flux inductance
    CurVelModel.motorParameters->L2 = 0.08477f; // H, inductance
    CurVelModel.motorParameters->nOfPolePairs = 2; // number of pole pairs
    CurVelModel.calculateMotorCVCoeff(CurVelModel.modelCVCoeff, CurVelModel.motorParameters);
    /*------------------------------------------------------------------------------------------*/

    /*------------------------------------------------------------------*/
    /*-------------------- TRIANGLE WAVE SETTINGS ---------------------*/
    svmCore.triangleWaveSettings->waveAmplitude = 1;
    svmCore.triangleWaveSettings->calculationStep = globalCalculationStep;
    svmCore.triangleWaveSettings->wavePeriod = 0.0001;
    svmCore.triangleWaveSettings->calculationTime = globalInitialCalculationTime;
    /*------------------------------------------------------------------*/

    /*--------------------------------------------------------------------*/
    /*-------------------- IVNVERTOR MODEL SETTINGS ---------------------*/
    float Udcmax = 311.87;
    svmCore.invertorSwitch->sw1 = 0;
    svmCore.invertorSwitch->sw2 = 0;
    svmCore.invertorSwitch->sw3 = 0;
    svmCore.invertorSwitch->sw4 = 0;
    svmCore.invertorSwitch->sw5 = 0;
    svmCore.invertorSwitch->sw6 = 0;
    /*--------------------------------------------------------------------*/



    /****************************************************************/
    /*-------------------- REGULATOR SETTINGS ---------------------*/


    /*-------------------- FLUX REGULATOR ---------------------*/
    Regulator.fluxRegulator->ki = 30300; // 30300
    Regulator.fluxRegulator->kp = 11410; //11410
    Regulator.fluxRegulator->saturationOutputMax = 16.4223;
    Regulator.fluxRegulator->saturationOutputMin = 0;
    Regulator.fluxRegulator->saturationOutput = 0;
    Regulator.fluxRegulator->clampingStatus = false;
    Regulator.fluxRegulator->saturationCheckStatus = false;
    Regulator.fluxRegulator->signCheckStatus = false;
    Regulator.fluxRegulator->measuredValue = 0;
    /*------------------------------------------------------*/

   /*-------------------- VELOCITY REGULATOR ---------------------*/
    Regulator.velocityRegulator->ki = 4650000; // 4650000
    Regulator.velocityRegulator->kp = 3720; // 3720
    Regulator.velocityRegulator->saturationOutputMax = 29.1228;
    Regulator.velocityRegulator->saturationOutputMin = -29.1228;
    Regulator.velocityRegulator->saturationOutput = 0;
    Regulator.velocityRegulator->clampingStatus = false;
    Regulator.velocityRegulator->saturationCheckStatus = false;
    Regulator.velocityRegulator->signCheckStatus = false;
    Regulator.velocityRegulator->measuredValue = 0;
    /*------------------------------------------------------*/

    /*-------------------- ID REGULATOR ---------------------*/
    Regulator.idRegulator->ki = 2915.6; // 2915.6
    Regulator.idRegulator->kp = 22.3961;// 22.3961
    Regulator.idRegulator->saturationOutputMax = Udcmax; // (3*sqrt(2))/(pi*sqrt(3))*Us = 400(3*sqrt(2))/(3.141592*sqrt(3)) = 311.87
    Regulator.idRegulator->saturationOutput = - Udcmax;
    Regulator.idRegulator->clampingStatus = false;
    Regulator.idRegulator->saturationCheckStatus = false;
    Regulator.idRegulator->signCheckStatus = false;
    Regulator.idRegulator->measuredValue = 0;
    /*------------------------------------------------------*/

    /*-------------------- IQ REGULATOR ---------------------*/
    Regulator.iqRegulator->ki = 2915.6; // 2915.6
    Regulator.iqRegulator->kp = 22.3961; // 22.3961
    Regulator.iqRegulator->saturationOutputMax = sqrt((Udcmax * Udcmax) - (Regulator.idRegulator->saturationOutput * Regulator.idRegulator->saturationOutput)); // sqrt(Udcmax^2 - u1d^2) dynamically
    Regulator.iqRegulator->saturationOutputMin = - Regulator.iqRegulator->saturationOutputMax;
    Regulator.iqRegulator->clampingStatus = false;
    Regulator.iqRegulator->saturationCheckStatus = false;
    Regulator.iqRegulator->signCheckStatus = false;
    Regulator.iqRegulator->measuredValue = 0;
    /*------------------------------------------------------*/

    /****************************************************************/




    /*--------------------------------------------------------------*/
    /*-------------------- WANTED VALUES INPUT ---------------------*/
    // now hardcoded, change later
    Regulator.fluxRegulator->wantedValue = 1;
    Regulator.velocityRegulator->wantedValue = 50;
    Regulator.idRegulator->wantedValue = 0;
    Regulator.iqRegulator->wantedValue = 0;
    /*--------------------------------------------------------------*/





    float inputI1 = 0;
    float inputI2 = 0;
    float inputI3 = 0;

    if(modeSelection == 2)
    {


    /*------------------------------------------------------------*/
    /*-------------------- PROGRAM SETTINGS ---------------------*/
    int verboseOutput = false;
    std::cout << "\n\r------------------------------------------\n";
    std::cout << "Select verbose output:\n0 - disabled\n1 - enabled\n";
    std::cout << "------------------------------------------\n";
    scanf("%i", &verboseOutput);
    /*------------------------------------------------------------*/
        /*------------------------------------------------------------------------*/
        /*-------------------- OUTPUT CSV DATA FILE CREATION ---------------------*/
        std::ofstream globalSimulationData;
        globalSimulationData.open("outputData/globalSimulationData.csv",std::ofstream::out | std::ofstream::trunc);
        /*-------------------------------------------------------------------*/


        std::chrono::time_point<std::chrono::system_clock> startTime;
        std::chrono::time_point<std::chrono::system_clock> endTime;


        /*
        * @brief Initial values settings
        *
        * */

        masterInput[0] = globalSimulationTime;
        masterInput[1] = globalCalculationStep;
        masterInput[2] = minMaxCommonModeVoltageConstant;
        masterInput[3] = globalCalculationStep/2;
        masterInput[4] = inputI1;
        masterInput[5] = inputI2;
        masterInput[6] = inputI3;
        masterInput[7] = MotorModel.modelVariables->motorMechanicalAngularVelocity;
        masterInput[8] = CurVelModel.modelCVCoeff->R2MLmDL2;
        masterInput[9] = CurVelModel.modelCVCoeff->R2DL2;
        masterInput[10] = CurVelModel.modelCVCoeff->nOfPolePairs;
        masterInput[11] = svmCore.triangleWaveSettings->waveAmplitude;
        masterInput[12] = svmCore.triangleWaveSettings->calculationStep;
        masterInput[13] = svmCore.triangleWaveSettings->wavePeriod;
        masterInput[14] = svmCore.triangleWaveSettings->calculationTime;
        masterInput[15] = Udcmax;
        masterInput[16] = Regulator.fluxRegulator->ki;
        masterInput[17] = Regulator.fluxRegulator->kp;
        masterInput[18] = Regulator.fluxRegulator->saturationOutputMax;
        masterInput[19] = Regulator.fluxRegulator->saturationOutputMin;
        masterInput[20] = Regulator.fluxRegulator->iSum;
        masterInput[21] = Regulator.velocityRegulator->ki;
        masterInput[22] = Regulator.velocityRegulator->kp;
        masterInput[23] = Regulator.velocityRegulator->saturationOutputMax;
        masterInput[24] = Regulator.velocityRegulator->saturationOutputMin;
        masterInput[25] = Regulator.velocityRegulator->iSum;
        masterInput[26] = Regulator.idRegulator->ki;
        masterInput[27] = Regulator.idRegulator->kp;
        masterInput[28] = Regulator.idRegulator->saturationOutput;
        masterInput[29] = Regulator.idRegulator->iSum;
        masterInput[30] = Regulator.iqRegulator->ki;
        masterInput[31] = Regulator.iqRegulator->kp;
        masterInput[32] = Regulator.iqRegulator->iSum;
        masterInput[33] = Regulator.fluxRegulator->wantedValue;
        masterInput[34] = Regulator.velocityRegulator->wantedValue;
        masterInput[35] = Regulator.idRegulator->wantedValue;
        masterInput[36] = Regulator.iqRegulator->wantedValue;
        masterInput[37] = CurVelModel.modelCVVariables->psi2alpha;
        masterInput[38] = CurVelModel.modelCVVariables->psi2beta;
        /***************************************************************/
        /*-------------------- MAIN PROGRAM LOOP ---------------------*/


        startTime = std::chrono::system_clock::now();

        for(int i = 0; i<10000;i++) // replace with while in production, but in this model, it is suitable to use for cycle
        {
            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
            {
                std::cout << "iteration number: " << i << "\n";
            }
            /*-------------------------------------------------------------------------------------------------------*/

            masterInput[0] = globalSimulationTime;
            masterInput[4] = inputI1;
            masterInput[5] = inputI2;
            masterInput[6] = inputI3;
            masterInput[7] = MotorModel.modelVariables->motorMechanicalAngularVelocity;
            masterInput[14] = svmCore.triangleWaveSettings->calculationTime;
            masterInput[20] = Regulator.fluxRegulator->iSum;
            masterInput[25] = Regulator.velocityRegulator->iSum;
            masterInput[28] = Regulator.idRegulator->saturationOutput;
            masterInput[29] = Regulator.idRegulator->iSum;
            masterInput[32] = Regulator.iqRegulator->iSum;
            masterInput[37] = CurVelModel.modelCVVariables->psi2alpha;
            masterInput[38] = CurVelModel.modelCVVariables->psi2beta;


            //kernel

            OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_masterInput}, 0 /* 0 means from host*/));

            OCL_CHECK(err, err = q.enqueueTask(krnl_calculateCurVelModel));

            OCL_CHECK(err, q.enqueueMigrateMemObjects({buffer_masterOutput}, CL_MIGRATE_MEM_OBJECT_HOST));

            OCL_CHECK(err, q.finish());




            svmCore.invertorSwitch->sw1 = masterOutput[0];
            svmCore.invertorSwitch->sw2 = masterOutput[1];
            svmCore.invertorSwitch->sw3 = masterOutput[2];
            svmCore.invertorSwitch->sw4 = masterOutput[3];
            svmCore.invertorSwitch->sw5 = masterOutput[4];
            svmCore.invertorSwitch->sw6 = masterOutput[5];

            svmCore.triangleWaveSettings->calculationTime = masterOutput[6];
            Regulator.fluxRegulator->iSum = masterOutput[7];
            Regulator.velocityRegulator->iSum = masterOutput[8];
            Regulator.idRegulator->saturationOutput = masterOutput[9];
            Regulator.idRegulator->iSum = masterOutput[10];
            Regulator.iqRegulator->iSum = masterOutput[11];
            CurVelModel.modelCVVariables->psi2alpha = masterOutput[12];
            CurVelModel.modelCVVariables->psi2beta = masterOutput[13];



        // we got switches from kernel

            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
            {
                std::cout << "sw1: " << svmCore.invertorSwitch->sw1 << "\n";
                std::cout << "sw2: " << svmCore.invertorSwitch->sw2 << "\n";
                std::cout << "sw3: " << svmCore.invertorSwitch->sw3 << "\n";
                std::cout << "sw4: " << svmCore.invertorSwitch->sw4 << "\n";
                std::cout << "sw5: " << svmCore.invertorSwitch->sw5 << "\n";
                std::cout << "sw6: " << svmCore.invertorSwitch->sw6 << "\n";

            }
            /*------------------------------------------------------------------------------------------------------*/



            /*-------------------- SIMULATED INVERTOR FOR SIMULATION WITH 3 PHASE CONTROLLED THYRISTOR 400 V ---------------------*/
            // invertor voltage reconstruction for phase A, B, C
            Invertor.invertorReconstructVoltages(svmCore.invertorSwitch, Invertor.reconstructedInvertorOutputVoltage, uDC);
            /*-------------------------------------------------------------------------------------------------------------------*/

            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
            {
                std::cout << "reconstructed u1a: " << Invertor.reconstructedInvertorOutputVoltage->u1a << "\n";
                std::cout << "reconstructed u1b: " << Invertor.reconstructedInvertorOutputVoltage->u1b << "\n";
                std::cout << "reconstructed u1c: " << Invertor.reconstructedInvertorOutputVoltage->u1c << "\n";
            }
            /*------------------------------------------------------------------------------------------------------*/


            /******************************************************************************/
            /*-------------------- VIRTUAL ASYNCHRONOUS MOTOR MODEL ---------------------*/


            /*---------------------------------------------------------------------------*/
            /*-------------------- CLARKE TRANSFORM FOR ASM MODEL ---------------------*/
            MotorModel.modelVariables->u1alpha = Transformation.clarkeTransform1(Invertor.reconstructedInvertorOutputVoltage->u1a, Invertor.reconstructedInvertorOutputVoltage->u1b, Invertor.reconstructedInvertorOutputVoltage->u1c, 0.6667);
            MotorModel.modelVariables->u1beta = Transformation.clarkeTransform2(Invertor.reconstructedInvertorOutputVoltage->u1a, Invertor.reconstructedInvertorOutputVoltage->u1b, Invertor.reconstructedInvertorOutputVoltage->u1c, 0.6667);
            /*---------------------------------------------------------------------------*/

            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
                {
                    std::cout << "u1alpha to motor: " << MotorModel.modelVariables->u1alpha << "\n";
                    std::cout << "u1beta to motor: " << MotorModel.modelVariables->u1beta << "\n";
                }
            /*-----------------------------------------------------------------------------------------------------*/

            /*-----------------------------------------------------------------------------------*/
            /*-------------------- MAIN ASM MODEL CODE WITH RK4 ODE SOLVING ---------------------*/
            MotorModel.mathModelCalculateOnlineValue(MotorModel.odeCalculationSettings, MotorModel.modelVariables, MotorModel.stateSpaceCoeff, MotorModel.motorParameters);
            /*-----------------------------------------------------------------------------------*/
            /******************************************************************************/

            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
            {
                std::cout << "ASM i1alpha: " << MotorModel.modelVariables->i1alpha << "\n";
                std::cout << "ASM i1beta: " << MotorModel.modelVariables->i1beta << "\n";
                std::cout << "ASM motorTorque: " << MotorModel.modelVariables->motorTorque<< "\n";
                std::cout << "ASM motorMechanicalAngularVelocity: " << MotorModel.modelVariables->motorMechanicalAngularVelocity << "\n";
                std::cout << "ASM psi2alpha: " << MotorModel.modelVariables->psi2alpha << "\n";
                std::cout << "ASM psi2beta: " << MotorModel.modelVariables->psi2beta << "\n";
            }
            /*-----------------------------------------------------------------------------------------------------*/

            inputI1 = Transformation.inverseClarkeTransform1(MotorModel.modelVariables->i1alpha, MotorModel.modelVariables->i1beta);
            inputI2 = Transformation.inverseClarkeTransform2(MotorModel.modelVariables->i1alpha, MotorModel.modelVariables->i1beta);
            inputI3 = Transformation.inverseClarkeTransform3(MotorModel.modelVariables->i1alpha, MotorModel.modelVariables->i1beta);

            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
            {
                std::cout << "psi2alpha: " << CurVelModel.modelCVVariables->psi2alpha << "\n";
                std::cout << "psi2amplitude: " << masterOutput[14] << "\n";
                std::cout << "transformationAngle: " << masterOutput[17] << "\n";

            }
            /*--------------------------------------------------------------------------------------------------------*/

            /*--------------------------------------------------------------------------------------------------------------------------------------------------*/

            /****************************************************************************************************************************************************/


            /*-------------------------------------------------------------------------------*/
            /*-------------------- OUTPUT CSV DATA INSERTING TO A FILE ---------------------*/
            globalSimulationData << globalSimulationTime << "," << masterOutput[14] << ","  << MotorModel.modelVariables->motorMechanicalAngularVelocity <<"\n";
            /*-------------------------------------------------------------------------------*/

            /*----------------------------------------------------------------------------------------------------------------------*/
            /*-------------------- UPDATING SIMULATION TIME - ONLY FOR SIMULATION PURPOSES TO OUTPUT DATA CSV ---------------------*/
            globalSimulationTime = globalSimulationTime + globalCalculationStep;
            /*----------------------------------------------------------------------------------------------------------------------*/

            /*-------------------- CONSOLE OUTPUT FOR TESTING PURPOSES BASED ON A USER SETTINGS ---------------------*/
            if(verboseOutput)
            {
                std::cout << "------------------------------------------------------"<< "\n";
            }
            /*-------------------------------------------------------------------------------------------------------*/

            /*********************************************************************************/
        }
        endTime = std::chrono::system_clock::now();
        /*-------------------- OUTPUT CSV DATA FILE CLOSING ---------------------*/
        globalSimulationData.close();
        /*----------------------------------------------------------------------*/
        std::chrono::duration<double> diffTime = endTime - startTime;
        std::cout << "Time for the execution is: " << diffTime.count() << "\n";

    }


    if(modeSelection == 1)
    {

         printf("Keyboard input data mode\n\r");
        printf("------------------------------------\n\r");
        printf("Insert data divided by {space symbol}\n\r");
        printf("I1 I2 I3 MechanicalAngularVelocity psi2alpha[0] psi2beta[0] \n\r");



    scanf("%f %f %f %f %f %f", &inputI1, &inputI2, &inputI3, &MotorModel.modelVariables->motorMechanicalAngularVelocity, &CurVelModel.modelCVVariables->psi2alpha, &CurVelModel.modelCVVariables->psi2beta);
    printf("------------------------------------\n\r");
    printf("You have entered:\n\r");
    printf("I1 = %f\n\rI2 = %f\n\rI3 = %f\n\rMechanicalAngularVelocity = %f\n\rpsi2alpha[0] = %f\n\rpsi2beta = %f\n\r", inputI1, inputI2, inputI3, MotorModel.modelVariables->motorMechanicalAngularVelocity, CurVelModel.modelCVVariables->psi2alpha, CurVelModel.modelCVVariables->psi2beta);
    printf("------------------------------------\n\r");

        masterInput[0] = globalSimulationTime;
        masterInput[1] = globalCalculationStep;
        masterInput[2] = minMaxCommonModeVoltageConstant;
        masterInput[3] = globalCalculationStep/2;
        masterInput[4] = inputI1;
        masterInput[5] = inputI2;
        masterInput[6] = inputI3;
        masterInput[7] = MotorModel.modelVariables->motorMechanicalAngularVelocity;
        masterInput[8] = CurVelModel.modelCVCoeff->R2MLmDL2;
        masterInput[9] = CurVelModel.modelCVCoeff->R2DL2;
        masterInput[10] = CurVelModel.modelCVCoeff->nOfPolePairs;
        masterInput[11] = svmCore.triangleWaveSettings->waveAmplitude;
        masterInput[12] = svmCore.triangleWaveSettings->calculationStep;
        masterInput[13] = svmCore.triangleWaveSettings->wavePeriod;
        masterInput[14] = svmCore.triangleWaveSettings->calculationTime;
        masterInput[15] = Udcmax;
        masterInput[16] = Regulator.fluxRegulator->ki;
        masterInput[17] = Regulator.fluxRegulator->kp;
        masterInput[18] = Regulator.fluxRegulator->saturationOutputMax;
        masterInput[19] = Regulator.fluxRegulator->saturationOutputMin;
        masterInput[20] = Regulator.fluxRegulator->iSum;
        masterInput[21] = Regulator.velocityRegulator->ki;
        masterInput[22] = Regulator.velocityRegulator->kp;
        masterInput[23] = Regulator.velocityRegulator->saturationOutputMax;
        masterInput[24] = Regulator.velocityRegulator->saturationOutputMin;
        masterInput[25] = Regulator.velocityRegulator->iSum;
        masterInput[26] = Regulator.idRegulator->ki;
        masterInput[27] = Regulator.idRegulator->kp;
        masterInput[28] = Regulator.idRegulator->saturationOutput;
        masterInput[29] = Regulator.idRegulator->iSum;
        masterInput[30] = Regulator.iqRegulator->ki;
        masterInput[31] = Regulator.iqRegulator->kp;
        masterInput[32] = Regulator.iqRegulator->iSum;
        masterInput[33] = Regulator.fluxRegulator->wantedValue;
        masterInput[34] = Regulator.velocityRegulator->wantedValue;
        masterInput[35] = Regulator.idRegulator->wantedValue;
        masterInput[36] = Regulator.iqRegulator->wantedValue;
        masterInput[37] = CurVelModel.modelCVVariables->psi2alpha;
        masterInput[38] = CurVelModel.modelCVVariables->psi2beta;


        masterInput[0] = globalSimulationTime;
        masterInput[4] = inputI1;
        masterInput[5] = inputI2;
        masterInput[6] = inputI3;
        masterInput[7] = MotorModel.modelVariables->motorMechanicalAngularVelocity;
        masterInput[14] = svmCore.triangleWaveSettings->calculationTime;
        masterInput[20] = Regulator.fluxRegulator->iSum;
        masterInput[25] = Regulator.velocityRegulator->iSum;
        masterInput[28] = Regulator.idRegulator->saturationOutput;
        masterInput[29] = Regulator.idRegulator->iSum;
        masterInput[32] = Regulator.iqRegulator->iSum;
        masterInput[37] = CurVelModel.modelCVVariables->psi2alpha;
        masterInput[38] = CurVelModel.modelCVVariables->psi2beta;


        for(int i = 0;i<10;i++)
        {

            std::cout << "\n\n" << i <<" round\n/************************************/\n";
            OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_masterInput}, 0 /* 0 means from host*/));

            OCL_CHECK(err, err = q.enqueueTask(krnl_calculateCurVelModel));

            OCL_CHECK(err, q.enqueueMigrateMemObjects({buffer_masterOutput}, CL_MIGRATE_MEM_OBJECT_HOST));

            OCL_CHECK(err, q.finish());


            std::cout << "psi2amplitude: " << masterOutput[14] << "\n";
            std::cout << "psi2alpha: " << masterOutput[12] << "\n";
            std::cout << "psi2beta: " << masterOutput[13] << "\n";
            std::cout << "triangleWaveSettings.calculationTime: " << masterOutput[6] << "\n";
            std::cout << "transformationAngle: " << masterOutput[17] << "\n";
            std::cout << "sw1: " << masterOutput[0] << "\n";
            std::cout << "sw2: " << masterOutput[1] << "\n";
            std::cout << "sw3: " << masterOutput[2] << "\n";
            std::cout << "sw4: " << masterOutput[3] << "\n";
            std::cout << "sw5: " << masterOutput[4] << "\n";
            std::cout << "sw6: " << masterOutput[5] << "\n";
            std::cout << "fluxRegulator.iSum: " << masterOutput[7] << "\n";
            std::cout << "velocityRegulator.iSum: " << masterOutput[8] << "\n";
            std::cout << "idRegulator.saturationOutput: " << masterOutput[9] << "\n";
            std::cout << "idRegulator.iSum: " << masterOutput[10] << "\n";
            std::cout << "iqRegulator.iSum: " << masterOutput[11] << "\n";
            std::cout << "idRegulator.measuredValue: " << masterOutput[15] << "\n";
            std::cout << "idRegulator.wantedValue: " << masterOutput[15] << "\n";


            masterInput[0] = globalSimulationTime;
        masterInput[1] = globalCalculationStep;
        masterInput[2] = minMaxCommonModeVoltageConstant;
        masterInput[3] = globalCalculationStep/2;
        masterInput[4] = inputI1;
        masterInput[5] = inputI2;
        masterInput[6] = inputI3;
        masterInput[7] = MotorModel.modelVariables->motorMechanicalAngularVelocity;
        masterInput[8] = CurVelModel.modelCVCoeff->R2MLmDL2;
        masterInput[9] = CurVelModel.modelCVCoeff->R2DL2;
        masterInput[10] = CurVelModel.modelCVCoeff->nOfPolePairs;
        masterInput[11] = svmCore.triangleWaveSettings->waveAmplitude;
        masterInput[12] = svmCore.triangleWaveSettings->calculationStep;
        masterInput[13] = svmCore.triangleWaveSettings->wavePeriod;
        masterInput[14] = svmCore.triangleWaveSettings->calculationTime;
        masterInput[15] = Udcmax;
        masterInput[16] = Regulator.fluxRegulator->ki;
        masterInput[17] = Regulator.fluxRegulator->kp;
        masterInput[18] = Regulator.fluxRegulator->saturationOutputMax;
        masterInput[19] = Regulator.fluxRegulator->saturationOutputMin;
        masterInput[20] = Regulator.fluxRegulator->iSum;
        masterInput[21] = Regulator.velocityRegulator->ki;
        masterInput[22] = Regulator.velocityRegulator->kp;
        masterInput[23] = Regulator.velocityRegulator->saturationOutputMax;
        masterInput[24] = Regulator.velocityRegulator->saturationOutputMin;
        masterInput[25] = Regulator.velocityRegulator->iSum;
        masterInput[26] = Regulator.idRegulator->ki;
        masterInput[27] = Regulator.idRegulator->kp;
        masterInput[28] = Regulator.idRegulator->saturationOutput;
        masterInput[29] = Regulator.idRegulator->iSum;
        masterInput[30] = Regulator.iqRegulator->ki;
        masterInput[31] = Regulator.iqRegulator->kp;
        masterInput[32] = Regulator.iqRegulator->iSum;
        masterInput[33] = Regulator.fluxRegulator->wantedValue;
        masterInput[34] = Regulator.velocityRegulator->wantedValue;
        masterInput[35] = Regulator.idRegulator->wantedValue;
        masterInput[36] = Regulator.iqRegulator->wantedValue;
        masterInput[37] = CurVelModel.modelCVVariables->psi2alpha;
        masterInput[38] = CurVelModel.modelCVVariables->psi2beta;


        masterInput[0] = globalSimulationTime;
        masterInput[4] = inputI1;
        masterInput[5] = inputI2;
        masterInput[6] = inputI3;
        masterInput[7] = MotorModel.modelVariables->motorMechanicalAngularVelocity;
        masterInput[14] = svmCore.triangleWaveSettings->calculationTime;
        masterInput[20] = Regulator.fluxRegulator->iSum;
        masterInput[25] = Regulator.velocityRegulator->iSum;
        masterInput[28] = Regulator.idRegulator->saturationOutput;
        masterInput[29] = Regulator.idRegulator->iSum;
        masterInput[32] = Regulator.iqRegulator->iSum;
        masterInput[37] = CurVelModel.modelCVVariables->psi2alpha;
        masterInput[38] = CurVelModel.modelCVVariables->psi2beta;
        }



    }

    std::cout << "the end of the most useful program is here\n";

    /*-----------------------------------------------------------*/
    /*-------------------- MEMORY FREEING ---------------------*/
    free(MotorModel.odeCalculationSettings);
    free(MotorModel.stateSpaceCoeff);
    free(MotorModel.motorParameters);
    free(MotorModel.modelVariables);
    free(CurVelModel.motorParameters);
    free(CurVelModel.modelCVCoeff);
    free(CurVelModel.modelCVVariables);
    free(CurVelModel.odeCVCalculationSettings);
    free(svmCore.invertorSwitch);
    free(svmCore.triangleWaveSettings);
    free(Regulator.fluxRegulator);
    free(Regulator.velocityRegulator);
    free(Regulator.iqRegulator);
    free(Regulator.idRegulator);
    free(Invertor.reconstructedInvertorOutputVoltage);
    free(svmCore.coreInternalVariables);
    free(masterInput);
    free(masterOutput);
    /*-----------------------------------------------------------*/


}
```
